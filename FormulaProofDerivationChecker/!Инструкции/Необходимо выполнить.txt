		 [ВЫПОЛНЕНО]
1. По обходу дерева определить является ли данное дерево "усовершенствованным" от родительского. 
Иными словами проверка на то, что дерево есть дерево аксиомами с заменами, т.е. тоже аксиома.
Идея решения:
	1.1. Запускаем параллельный одинаковый неркурсивный обход двух деревьев.
	1.2. В узле не стыковки, где корни не равны, регистрируем замену. 
		 В словарь добавляем отображение переменной из аксиомы в Node её заменяющий в преобр. дереве.
	1.3. Узел замены можно пропустить. Их необходимо сравнивать, когда снова встречаем такую же
		 переменную в родительской аксиоме. 
	1.ps. На каждой встрече с расхождением мы проверяем содержится ли такая замена уже в словаре.
		 Если да, то сравниваем. В ином случае ->1.2.

		 [ВЫПОЛНЕНО]
1.75. Реализовать метод проверки правила MP. MP(parent, child, brother)

		 [ВЫПОЛНЕНО]
2. Метод main(). Настроить чтение гипотез, аксиом и самого вывода. Гипотезы и аксиомы хранить в виде формул в коллекциях HashSet.
Настроить класс формула, так чтобы объекты этого класса могли сравниваться и храниться в HashSet
Вывод добавлять в словарь Dictionary<Formula, string> где string - (аксиома или гипотеза или MP)
Вывод читать построчно. Сценарии обработки каждой строки могут быть следующими:
	2.1. Встретилась гипотеза? Проверяем множество гипотез, если находим совпадение, то следующая строка.
	2.2. Встретилась аксиома? Перебираем множество всех аксиом и пытаемся с помощью NodeScanner проверить аксиоматичность.
	2.3. Если не аксиома и не гипотеза, то возможно MP.
			Перебираем весь предыдущий вывод (пока O(n^2)). И проверяем метод MP(). ->1.75